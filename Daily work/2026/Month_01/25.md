## <font color = blue face=楷体 size=6>日期 1.25 </font>

## <font color = green>知识学习 </font>
### <font color = purple>专业知识 </font>
+ <a id = "01-1">  [<font color = red>跳转</font>](#01-2)
   > <font color = o> 说明 </font>
### <font color = purple>生活常识 </font>

### <font color = purple>求职 </font>



## <font color = green>心得 </font>
### <font color = purple>学习心得 </font>
+ 
### <font color = purple>生活技巧 </font>

### <font color = purple>Good Idea </font>



## <font color = green>新名词 </font>
### <font color = purple>英文单词 </font>
### <font color = purple>新词 </font>



## <font color = green>各类网站 </font>


## <font color = green>资源文件 </font>


## <font color = green>新闻 </font>


## <font color = green>新知 </font>
+ 

## <font color = green>待办事项 </font>
### <font color = purple>事项 </font>
- [ ] ...
### <font color = purple>已解决 </font>
### <font color = purple>疑问 </font>
- [ ] ...
### <font color = purple>明日计划 </font>
- [ ] ...


## <font color = green>备注 </font>
  1. <a id ="01-2">[<font color = red>跳回</font>](#01-1)

知识库内容是如何保存的？如果出现错误内容是否会污染LLM，以及同一内容进行更正后，错误的信息LLM是否会及时清除？

写提示词的一些模板 
来源：coze智能体创建时，提示词编写框自带的提示模板
通用格式
```
# 角色：{#InputSlot placeholder="角色名称" mode="input"#}{#/InputSlot#}
{#InputSlot placeholder="角色概述和主要职责的一句话描述" mode="input"#}{#/InputSlot#}

## 目标：
{#InputSlot placeholder="角色的工作目标，如果有多目标可以分点列出，但建议更聚焦1-2个目标" mode="input"#}{#/InputSlot#}

## 技能：
1.  {#InputSlot placeholder="为了实现目标，角色需要具备的技能1" mode="input"#}{#/InputSlot#}
2. {#InputSlot placeholder="为了实现目标，角色需要具备的技能2" mode="input"#}{#/InputSlot#}
3. {#InputSlot placeholder="为了实现目标，角色需要具备的技能3" mode="input"#}{#/InputSlot#}

## 工作流：
1. {#InputSlot placeholder="描述角色工作流程的第一步" mode="input"#}{#/InputSlot#}
2. {#InputSlot placeholder="描述角色工作流程的第二步" mode="input"#}{#/InputSlot#}
3. {#InputSlot placeholder="描述角色工作流程的第三步" mode="input"#}{#/InputSlot#}

## 输出格式：
{#InputSlot placeholder="如果对角色的输出格式有特定要求，可以在这里强调并举例说明想要的输出格式" mode="input"#}{#/InputSlot#}

## 限制：
- {#InputSlot placeholder="描述角色在互动过程中需要遵循的限制条件1" mode="input"#}{#/InputSlot#}
- {#InputSlot placeholder="描述角色在互动过程中需要遵循的限制条件2" mode="input"#}{#/InputSlot#}
- {#InputSlot placeholder="描述角色在互动过程中需要遵循的限制条件3" mode="input"#}{#/InputSlot#}
```


任务执行
```
# 角色 
你是{#InputSlot placeholder="角色设定，比如xx领域的专家"#}{#/InputSlot#}
你的目标是{#InputSlot placeholder="希望模型执行什么任务，达成什么目标"#}{#/InputSlot#}

{#以下可以采用先总括，再展开详细说明的方式，描述你希望智能体在每一个步骤如何进行工作，具体的工作步骤数量可以根据实际需求增删#}
## 工作步骤 
1. {#InputSlot placeholder="工作流程1的一句话概括"#}{#/InputSlot#} 
2. {#InputSlot placeholder="工作流程2的一句话概括"#}{#/InputSlot#} 
3. {#InputSlot placeholder="工作流程3的一句话概括"#}{#/InputSlot#}

### 第一步 {#InputSlot placeholder="工作流程1标题"#}{#/InputSlot#} 
{#InputSlot placeholder="工作流程步骤1的具体工作要求和举例说明，可以分点列出希望在本步骤做哪些事情，需要完成什么阶段性的工作目标"#}{#/InputSlot#}
### 第二步 {#InputSlot placeholder="工作流程2标题"#}{#/InputSlot#} 
{#InputSlot placeholder="工作流程步骤2的具体工作要求和举例说明，可以分点列出希望在本步骤做哪些事情，需要完成什么阶段性的工作目标"#}{#/InputSlot#}
### 第三步 {#InputSlot placeholder="工作流程3标题"#}{#/InputSlot#}
{#InputSlot placeholder="工作流程步骤3的具体工作要求和举例说明，可以分点列出希望在本步骤做哪些事情，需要完成什么阶段性的工作目标"#}{#/InputSlot#}

通过这样的对话，你可以{#InputSlot placeholder="智能体工作目标再次强调"#}{#/InputSlot#}
```


角色扮演
```
你将扮演一个人物角色{#InputSlot placeholder="角色名称"#}{#/InputSlot#}，以下是关于这个角色的详细设定，请根据这些信息来构建你的回答。 

**人物基本信息：**
- 你是：{#InputSlot placeholder="角色的名称、身份等基本介绍"#}{#/InputSlot#} 
- 人称：第一人称
- 出身背景与上下文：{#InputSlot placeholder="交代角色背景信息和上下文"#}{#/InputSlot#}
**性格特点：**
- {#InputSlot placeholder="性格特点描述"#}{#/InputSlot#}
**语言风格：**
- {#InputSlot placeholder="语言风格描述"#}{#/InputSlot#} 
**人际关系：**
- {#InputSlot placeholder="人际关系描述"#}{#/InputSlot#}
**过往经历：**
- {#InputSlot placeholder="过往经历描述"#}{#/InputSlot#}
**经典台词或口头禅：**
补充信息: 即你可以将动作、神情语气、心理活动、故事背景放在（）中来表示，为对话提供补充信息。
- 台词1：{#InputSlot placeholder="角色台词示例1"#}{#/InputSlot#} 
- 台词2：{#InputSlot placeholder="角色台词示例2"#}{#/InputSlot#}

要求： 
- 根据上述提供的角色设定，以第一人称视角进行表达。 
- 在回答时，尽可能地融入该角色的性格特点、语言风格以及其特有的口头禅或经典台词。
- 如果适用的话，在适当的地方加入（）内的补充信息，如动作、神情等，以增强对话的真实感和生动性。 
```

技能调用
```
{#使用说明：本模板以搜索插件的调用总结场景进行举例，真实使用时可将“search”工具替换成当前智能体已配置的插件或工作流名称，键入“{”可以快速引用当前智能体已配置的技能。#}
# 角色
你是一个{#InputSlot placeholder="智能体人设"#}资深搜索大师{#/InputSlot#}，能够熟练调用{#LibraryBlock id="7372463719307264027" uuid="O4g66HC0_97yQ5aQYreR4" type="plugin" apiId="7372463719307296795"#}search{#/LibraryBlock#}工具，为用户{#InputSlot placeholder="智能体工作目标"#}搜索总结各类问题{#/InputSlot#}。

## 技能
### 技能 1: {#InputSlot placeholder="智能体技能"#}按用户需求搜索总结{#/InputSlot#}
1. 当用户{#InputSlot placeholder="技能调用触发场景"#}提出具体的搜索需求时{#/InputSlot#}，使用{#LibraryBlock id="7372463719307264027" uuid="O4g66HC0_97yQ5aQYreR4" type="plugin" apiId="7372463719307296795"#}search{#/LibraryBlock#}{#InputSlot placeholder="调用技能进行什么操作"#}进行搜索{#/InputSlot#}；
2. 对{#InputSlot placeholder="调用技能返回的结果"#}搜到的结果{#/InputSlot#}严格按照以下示例回复的格式进行回复：
==示例回复==
{#InputSlot placeholder="期望输出的格式示例，建议使用Markdown可以更清晰的展现"#}
- 🔗链接1：[<搜索结果名称>](<搜索结果链接>)
- 📒总结：<搜索结果内容100字总结>
---
- 🔗链接2：[<搜索结果名称>](<搜索结果链接>)
- 📒总结：<搜索结果内容100字总结>
---
- 🔗链接3：[<搜索结果名称>](<搜索结果链接>)
- 📒总结：<搜索结果内容100字总结>
---
{#/InputSlot#}
==示例结束==

## 限制:
- 所输出的内容必须按照给定的示例回复格式进行组织，不能偏离框架要求。
- 每次对话必须调用{#LibraryBlock id="7372463719307264027" uuid="O4g66HC0_97yQ5aQYreR4" type="plugin" apiId="7372463719307296795"#}search{#/LibraryBlock#}。
```

ceze工作流使用通用技巧:
1. 要善用【试运行】功能。
最好是先整个流程试运行，然后看有没有报错。如果没有报错，那么再看结果是否正常，不正常的话可以进入相关节点进行调试。
由于已经先运行了一次，所以在每个节点处已经传入了参数。可以通过不断修改参数来检查输出结果，并找出问题。
在每个节点处试运行，会降低Token的使用。
2. 提示词细节
	 + 有时候LLM会被自己的思考过程也写进去结果中，这时候需要告诉它只输出结果，不要输出其他内容
	+ 大多数情况下需要明确告诉LLM生成的格式，否则它会随便乱输出

coze工作流创建实例1：文本扩写
流程1：开始
用户输入标题、大纲（可选）
流程2：判断
如果大纲为空，则调用大模型补充大纲
> 注1：如果不在提示词中说明只补充大纲的一级标题，LLM会随机补充标题，可能补充到二级

流程3：变量聚合
对于相同的输出格式string，即大纲部分，需要把它变成一个变量方便后续调用参数。否则会由于判断产生两条分支线，增加流程图的书写（但实际运行过程一样）
> 注1：大模型处的output为json格式的string，而自己输入的时候则是一般的string，但实际上可以同时聚合变量。
> 不过有可能会在后续进行数组循环时出现问题：
> 1. 循环格式要求输入参数是 array of string格式，自己在对话框中是无法进行调整的，但是大模型可以设置输出变量为array of string
> 解决方法：中间多插入一个大模型节点，告诉它需要把这个字符串的标题变成array of string格式，并严格要求内容和标题一致，无需扩写或修改，且仅输出最终结果。再在输出变量选择格式类型为array of string即可。
> 2. 可能要求输出的格式是json格式

流程4：子标题生成
对大纲的一级标题生成二级子标题
> 注1：最好把输出格式告诉LLM，有时候比较笨，经常乱输出格式

流程5：循环
对每个子标题进行扩写
> 注1：具体思路参考coze的教程 https://docs.coze.cn/tutorial/generate_articles
> 注2：循环是按照一级标题进行循环的，而非二级子标题，如果想要按照二级子标题进行循环，那就要在【子标题生成】这一步中告诉LLM，采用二级标题进行分组的输出格式。

流程6：文本处理
用于对循环后产生的字符串进行拼接，实现对文章进行排版
> 注1：由于循环格式输出的是array of string格式，所以需要在【字符串拼接】处设置使用`\n`来进行拼接数组。
> 注2：如果需要指定格式输入内容，直接在文本框中按照目标格式输入就好。
> 例如：输入参数是两个字符串`s1`，`s2`。现在需要把`s1`和`s2`按照有序列表输出，则直接输入
> ```
> 1. s1
> 2. s2
> ```
> 不要用`\n`来代替回车键，显示时会变成`\\n` 

流程7：输出
返回最终的文本

飞书使用教程

Trae  https://www.trae.cn/
这里的自然语言编程，并不是一般意义上理解的，把所需功能描述一遍后，将整个开发过程完全托管给 AI 的开发方式。“积流成江” 的开发过程，仍然是典型意义上的工程师开发。除去功能描述外，更多的是编码逻辑和技术方案本身的描述。只是，这种逻辑是用自然语言，而非代码的方式呈现。
https://docs.trae.cn/ide/ai-coding-case-streams-to-river


python

Chromium是Google的开源项目，而Chrome是基于Chromium开发的浏览器。
以下是Chromium和Chrome的一些主要区别123：

特征	Chromium	Chrome
开源性	开源	闭源
功能	功能更多，新功能先在此实现	功能相对较少，但更稳定
自动更新	不开放自动更新功能	可自动连上Google的服务器更新
发布频率	更新频繁，几乎每天都有新版本	更新较慢，通常每月一次
版本稳定性	可能不太稳定	更稳定，相当于beta版
商业插件支持	不支持商业收费插件	支持一些商业的收费插件
内置软件	不包含Google的某些专有服务和功能，如内置的Google搜索、同步功能等	包含Google的专有服务和功能
安装方式	通常为免安装，下载zip封装版后解压缩即可使用	需要安装程序进行安装
总的来说，Chromium更适合喜欢尝试新功能和技术的用户，而Chrome则更适合追求稳定性和商业插件支持的用户。





codex


https://zhuanlan.zhihu.com/p/1968659891242635663



学习该网站的文章分类方式
https://www.cnblogs.com/llm-api/p/19509763/openai-codex-api-123324242
> 该文章提到了GPT-5-Codex LLM模型已经不再提供API服务


https://www.163.com/dy/article/JVOI1JEP0556703U.html
Codex 的发布是 OpenAI 扩展 ChatGPT 产品功能的又一大步，继视频平台 Sora、研究工具 Deep Research 和浏览器助手 Operator 之后，再添一项强大工具，进一步增强用户粘性和付费动力。
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTQ0MzM4OTQwMCwtMTQ4MzUzNDA4MCwtOT
I3NjI3NDUxLDE4MDg4ODAyNSwtMTE2OTEyNDk1MCwtMTk2NzM3
NzU5NV19
-->